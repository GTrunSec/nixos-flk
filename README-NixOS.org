#+TITLE: README NixOS

* Configuration
#+begin_src nix :exports both :tangle "~/.config/nixpkgs/nixos-flk/configuration.nix"
# this file is an impure recreation of the flake profile currently deployed
# based on the systems hostname. The purpose is so tools which do not yet have
# flake support (e.g `nixos-option`), can work as expected.
{ lib, ... }:
let
  inherit (builtins) attrNames readDir;

  hostname = lib.fileContents /etc/hostname;
  host = "/etc/nixos/hosts/${hostname}.nix";
  config =
    if (builtins.pathExists host) then
      [ host ]
    else
      [ /etc/nixos/hosts/NixOS.nix ];
in
{
  imports = (import ./modules/list.nix) ++ [
    "${
      builtins.fetchTarball
        "https://github.com/rycee/home-manager/archive/master.tar.gz"
      }/nixos"
    /etc/nixos/profiles/core.nix
  ] ++ config;

  networking.hostName = hostname;
  nix.nixPath = [
    "nixpkgs=${<nixpkgs>}"
    "nixos-config=/etc/nixos/configuration.nix"
    "nixpkgs-overlays=/etc/nixos/overlays"
  ];

  nixpkgs.overlays =
    let
      overlays = map
        (name: import (./overlays + "/${name}"))
        (attrNames (readDir ./overlays));
    in
    overlays;
}
#+end_src

* hardward
#+begin_src nix :exports both :tangle "~/.config/nixpkgs/nixos-flk/hosts/hardware/NixOS-hardware-configuration.nix"
# Do not modify this file!  It was generated by ‘nixos-generate-config’
# and may be overwritten by future invocations.  Please make changes
# to /etc/nixos/configuration.nix instead.
{ config, lib, pkgs, ... }:

{
  boot.initrd.availableKernelModules = [ "xhci_pci" "ahci" "usb_storage" "usbhid" "sd_mod" ];
  boot.initrd.kernelModules = [ ];
  boot.extraModulePackages = [ ];

  fileSystems."/boot" =
    { device = "/dev/disk/by-uuid/CF48-6C3C";
      fsType = "vfat";
    };

  fileSystems."/" =
    { device = "/dev/disk/by-uuid/a8b91326-9a5f-47c9-b827-19e1ce17cfe8";
      fsType = "xfs";
    };

  swapDevices =
    [ { device = "/dev/disk/by-uuid/d05ef9fb-1433-4819-b1a7-e15b5a7b9a90"; }
    ];

    fileSystems."/qemu-img" =
    { device = "/dev/disk/by-uuid/749df476-c355-469a-9d00-4565a07901bf";
      fsType = "xfs";
    };

  nix.maxJobs = lib.mkDefault 12;
  powerManagement.cpuFreqGovernor = lib.mkDefault "powersave";
}
#+end_src

* hosts
** default.nix
#+begin_src nix :exports both :tangle "~/.config/nixpkgs/nixos-flk/hosts/default.nix"
{ home
, photoprism-flake
, lib
, nixos
, master
, pkgset
, self
, system
, utils
, ...
}:
let
  inherit (utils) recImport;
  inherit (builtins) attrValues removeAttrs;
  inherit (pkgset) osPkgs pkgs;

  config = hostName:
    lib.nixosSystem {
      inherit system;

      modules =
        let
          inherit (home.nixosModules) home-manager;
          inherit (photoprism-flake.nixosModules) photoprism;
          core = self.nixosModules.profiles.core;

          global = {
            networking.hostName = hostName;
            nix.nixPath = let path = toString ../.; in
              [
                "nixpkgs=${master}"
                "nixos=${nixos}"
                "nixos-config=${path}/configuration.nix"
                "nixpkgs-overlays=${path}/overlays"
              ];

            nixpkgs = { pkgs = osPkgs; };

            nix.registry = {
              nixos.flake = nixos;
              nixflk.flake = self;
              nixpkgs.flake = master;
            };
          };

          overrides = {
            # use latest systemd
            systemd.package = pkgs.systemd;

            nixpkgs.overlays =
              let
                override = import ../pkgs/override.nix pkgs;

                overlay = pkg: final: prev: {
                  "${pkg.pname}" = pkg;
                };
              in
              map overlay override;
          };

          local = import "${toString ./.}/${hostName}.nix";

          # Everything in `./modules/list.nix`.
          flakeModules =
            attrValues (removeAttrs self.nixosModules [ "profiles" ]);

        in
        flakeModules ++ [ core global local home-manager overrides photoprism];

    };

  hosts = recImport {
    dir = ./.;
    _import = config;
  };
in
hosts
#+end_src

**  NixOS
#+begin_src nix :exports both :tangle "~/.config/nixpkgs/nixos-flk/hosts/NixOS.nix"
{
  ### root password is empty by default ###
  imports = [ ../users/nixos ../users/root ./hardware/NixOS-hardware-configuration.nix
              ../local/input.nix
              ../profiles/graphical
              ../profiles/graphical/nvidia.nix
              ../profiles/devices
              ../profiles/ssh
              ../profiles/code
              ../profiles/virt
              ../profiles/applications
              ../profiles/nsm
              ../profiles/data
            ];

  networking.firewall = {
    # 8888 -> Jupyterlab 8889 -> JuliaPluto
    allowedTCPPorts = [ 8888 8889];
    allowedUDPPorts = [ 8888 8889];
  };


  boot.loader.systemd-boot.enable = true;
  boot.loader.efi.canTouchEfiVariables = true;
  ## ssd
  services.fstrim.enable = true;

  networking.networkmanager.enable = true;
  # Define your hostname.
  fileSystems."/".options = [ "noatime" "nodiratime" "discard" ];

}
#+end_src

**  niximage
#+begin_src nix :exports both :tangle "~/.config/nixpkgs/nixos-flk/hosts/niximg.nix"
{ modulesPath, ... }: {
  imports = [
    # passwd is nixos by default
    ../users/nixos
    # passwd is empty by default
    ../users/root
    "${modulesPath}/installer/cd-dvd/iso-image.nix"
  ];

  isoImage.makeEfiBootable = true;
  isoImage.makeUsbBootable = true;
  networking.networkmanager.enable = true;
}
#+end_src

* lib
- utils
  #+begin_src nix :exports both :tangle "~/.config/nixpkgs/nixos-flk/lib/utils.nix"
{ lib, ... }:
let
  inherit (builtins) attrNames isAttrs readDir listToAttrs;

  inherit (lib) filterAttrs hasSuffix mapAttrs' nameValuePair removeSuffix;

  # mapFilterAttrs ::
  #   (name -> value -> bool )
  #   (name -> value -> { name = any; value = any; })
  #   attrs
  mapFilterAttrs = seive: f: attrs: filterAttrs seive (mapAttrs' f attrs);

  # Generate an attribute set by mapping a function over a list of values.
  genAttrs' = values: f: listToAttrs (map f values);

in
{
  inherit mapFilterAttrs genAttrs';

  recImport = { dir, _import ? base: import "${dir}/${base}.nix" }:
    mapFilterAttrs
      (_: v: v != null)
      (n: v:
        if n != "default.nix" && hasSuffix ".nix" n && v == "regular"
        then
          let name = removeSuffix ".nix" n; in nameValuePair (name) (_import name)

        else
          nameValuePair ("") (null))
      (readDir dir);

  # Convert a list to file paths to attribute set
  # that has the filenames stripped of nix extension as keys
  # and imported content of the file as value.
  pathsToImportedAttrs = paths:
    genAttrs' paths (path: {
      name = removeSuffix ".nix" (baseNameOf path);
      value = import path;
    });

}
  #+end_src

* local
** input
#+begin_src nix :exports both :tangle "~/.config/nixpkgs/nixos-flk/local/input.nix"
{ pkgs, ... }:

{
  i18n = {
    inputMethod = {
     enabled = "fcitx";
     fcitx.engines = with pkgs.fcitx-engines; [ cloudpinyin rime];
    };
  };
}
#+end_src
** locale
#+begin_src nix :exports both :tangle "~/.config/nixpkgs/nixos-flk/local/locale.nix"
{ ... }: {
  i18n.defaultLocale = "en_US.UTF-8";
  time.timeZone = "America/Los_Angeles";
}
#+end_src

* pkgs
** default
#+begin_src nix :exports both :tangle "~/.config/nixpkgs/nixos-flk/pkgs/default.nix"
final: prev:
let
  nixpkgs-hardenedlinux = prev.fetchgit {
    url = "https://github.com/hardenedlinux/nixpkgs-hardenedlinux";
    rev = "826b291257c7fdd9bb9460ef844396c8ed927955";
    sha256 = "sha256-VebFgB49NoA6C+lm2DfLGd0gCDLVNqNPCWJ0JgDT1rU=";
  };
in
{

  nuclear = prev.callPackage ./appimage/nuclear.nix {};
  motrix = prev.callPackage ./appimage/Motrix.nix {};
  shadowsocks-qt5 = prev.callPackage ./appimage/shadowsocks-qt5.nix {};
  #FIXME: spicy plugin BUG
  hardenedlinux-zeek = prev.callPackage "${nixpkgs-hardenedlinux}/pkgs/zeek" { KafkaPlugin = true; PostgresqlPlugin = true; Http2Plugin = true;};
  btest = prev.callPackage "${nixpkgs-hardenedlinux}/pkgs/python/btest" { python3Packages = prev.python37Packages; };

  #go packages
  horcrux = prev.callPackage ./go/horcrux {};
  govet = prev.callPackage ./go/govet {};
  got = prev.callPackage ./go/got {};

  #python
  promnesia =  prev.callPackage ./python/promnesia {python3Packages = prev.python37Packages;};
  orgparse=  prev.callPackage ./python/orgparse {python3Packages = prev.python37Packages;};
  hpi =  prev.callPackage ./python/HPI {python3Packages = prev.python37Packages;};
  #rust
  sudo-pair = prev.callPackage ./rust/sudo_pair {};
}
#+end_src

** appimage
*** build image

#+begin_src nix :exports both :tangle "~/.config/nixpkgs/nixos-flk/pkgs/appimage/build-appimage.nix"
{ pkgs }:
{
#{ fetchurl, runCommand }: {
  buildAppImage = { name, url, sha256, icon, categories }:
  let
    image = pkgs.fetchurl {
      inherit url sha256;
      executable = true;
    };
  in
    pkgs.runCommand name {} ''
      binDir="$out/bin"
      mkdir -p $binDir
      cat > ''${binDir}/${name} <<EOF
      #!${pkgs.stdenv.shell}
      ${pkgs.appimage-run}/bin/appimage-run ${image}
      EOF
      chmod +x ''${binDir}/${name}
      mkdir -p $out/share/applications
      cat > $out/share/applications/${name}.desktop <<EOF
      [Desktop Entry]
      Type=Application
      Exec=$out/bin/${name}
      Terminal=false
      Name=${name}
      Categories=${categories};
      Icon=${icon}
      EOF
    '';
}
#+end_src
*** Motrix
#+begin_src nix :exports both :tangle "~/.config/nixpkgs/nixos-flk/pkgs/appimage/Motrix.nix"
{ pkgs }: with pkgs; with (import ./build-appimage.nix { inherit pkgs; });
  let
    version = "1.5.15";
  in
buildAppImage {
    name = "motrix";
    url    = "https://github.com/agalwood/Motrix/releases/download/v${version}/Motrix-${version}.AppImage";
    sha256 = "sha256-/M/x+EFxz+9o/z5gLCoL4UZFnKBdMMT9bZ4ffZF1SyI=";
    icon   = fetchurl {
      url    = https://raw.githubusercontent.com/agalwood/Motrix/master/static/512x512.png;
      sha256 = "sha256-aGBccae981kL3tpfQx4oVXlPNdLRKM6iNGqjY6yAt4Q=";
    };
    categories = "download manager";
}
#+end_src
*** nuclear
#+begin_src nix :exports both :tangle "~/.config/nixpkgs/nixos-flk/pkgs/appimage/nuclear.nix"
{ pkgs }: with pkgs; with (import ./build-appimage.nix { inherit pkgs; });
buildAppImage {
  name   = "Nuclear";
  url    = https://github.com/nukeop/nuclear/releases/download/v0.6.3/nuclear-fca030.AppImage;
  sha256 = "sha256-SKPbLmO8CmJrbYtex66cY4rVXJQCgTrwu9F9FkDN17I=";
  icon   = fetchurl {
    url    = https://raw.githubusercontent.com/nukeop/nuclear/master/packages/app/resources/media/1024x1024.png;
    sha256 = "sha256-ROsh8UMDGJXW7kngGTfk7dJv8dVrl5FttaQ3k3nDFUA=";
  };
  categories = "AudioVideo";
}
#+end_src

*** shadowsocks-qt5

#+begin_src nix :exports both :tangle "~/.config/nixpkgs/nixos-flk/pkgs/appimage/shadowsocks-qt5.nix"
{ pkgs }: with pkgs; with (import ./build-appimage.nix { inherit pkgs; });
  let
    version = "3.0.1";
  in
buildAppImage {
    name = "shadowsocks-qt5";
    url    = "https://github.com/shadowsocks/shadowsocks-qt5/releases/download/v${version}/Shadowsocks-Qt5-${version}-x86_64.AppImage";
    sha256 = "sha256-5Nhe794JwpsyOTUU6K0YWOT2dk3GuNTaAlU5UhP5O0E=";
    icon   = fetchurl {
      url    = https://raw.githubusercontent.com/shadowsocks/shadowsocks-qt5/master/src/icons/shadowsocks-qt5.png;
      sha256 = "sha256-xRgO0n2t3RMDgzKXUBvVEFJ94GxMtBRo/ewKZ2Dxd/o=";
    };
    categories = "VPN client";

}
#+end_src

*** 1password
- https://1password.com/
#+begin_src nix :exports both :tangle "~/.config/nixpkgs/nixos-flk/pkgs/appimage/1password.nix"
{ pkgs }: with pkgs; with (import ./build-appimage.nix { inherit pkgs; });
  let
    version = "latest";
  in
    buildAppImage {
      name = "1password";
      url = "https://downloads.1password.com/linux/appimage/1password-${version}.AppImage";
      sha256 = "sha256-4KIzL5VS4giWBHRW5DD+27mWZAdaiHVNyQbNZIzI+uI=";
      icon   = fetchurl {
        url    = https://i.1password.com/media/buttons-and-icons/1password-x-inline-icon.svg;
        hash = "sha256-4Wp7PXhkkhcB4JvMOgWotbyTGnv5MBanPg2vvROmaTQ=";
      };
      categories = "password manager";
    }
#+end_src
** go
- got [[file:pkgs/go/got/]]
- govet [[file:pkgs/go/govet]]
- horcrux file:pkgs/go/horcrux
** python
- HPI [[file:pkgs/python/HPI/]]
- orgparse [[file:pkgs/python/orgparse/]]
- promnesia [[file:pkgs/python/promnesia/]]
** rust
- sudo_pair [[file:pkgs/rust/sudo_pair/]]
** Node packages
- my-node-packages file:pkgs/my-node-packages/
  #+begin_src json :exports both :tangle "~/.config/nixpkgs/nixos-flk/pkgs/my-node-packages/packages.json"
[
    "typescript-language-server",
    "tslint",
    "maildev",
    "@mermaid-js/mermaid-cli",
    "electron-builder",
    "electron",
    "electron-rebuild",
    "mathjax-node-cli"
]
  #+end_src

* Overlays
** polar-bookshelf

- [[https://github.com/burtonator/polar-bookshelf/releases][Releases · burtonator/polar-bookshelf]]

  #+begin_src conf :exports both :tangle "~/.config/nixpkgs/nixos-flk/overlays/polar-bookshelf.nix"
let version = "2.0.42";
in
final: prev: {
  polar-bookshelf = prev.polar-bookshelf.overrideAttrs (o: rec{
    inherit version;
    src = prev.fetchurl {
      url = "https://github.com/burtonator/polar-bookshelf/releases/download/v${version}/polar-desktop-app-${version}-amd64.deb";
      sha256 = "sha256-JyO71wyE6b0iHAYs/6/WbG+OdUVUUPpJla+ZUzg0Gng=";
    };

    installPhase = ''
    mkdir -p $out/share/polar-bookshelf
    mkdir -p $out/bin
    mkdir -p $out/lib

    mv opt/Polar/* $out/share/polar-bookshelf
    mv $out/share/polar-bookshelf/*.so $out/lib

    mv usr/share/* $out/share/

    ln -s $out/share/polar-bookshelf/polar-desktop-app $out/bin/polar-desktop-app

    substituteInPlace $out/share/applications/polar-desktop-app.desktop \
      --replace "/opt/Polar/polar-desktop-app" "$out/bin/polar-desktop-app"
    '';
  });
}

  #+end_src
** discord
#+begin_src nix :exports both :tangle "~/.config/nixpkgs/nixos-flk/overlays/discord.nix"
let version = "0.0.12";
in
final: prev: {
  discord = prev.discord.overrideAttrs (o: {
    inherit version;
    src = prev.fetchurl {
      url = "https://dl.discordapp.net/apps/linux/${version}/discord-${version}.tar.gz";
      sha256 = "sha256-aPLNPDl7XFSxWwjw2HPhTladoCSxLC5WWF+hyxDbP2M=";
    };
  });
}
#+end_src
** brave
#+begin_src nix :exports both :tangle "~/.config/nixpkgs/nixos-flk/overlays/brave.nix"
let version = "1.15.75";
in
final: prev: {
  brave = prev.brave.overrideAttrs (o: {
    inherit version;
    src = prev.fetchurl {
      url = "https://github.com/brave/brave-browser/releases/download/v${version}/brave-browser_${version}_amd64.deb";
      sha256 = "sha256-z6NXS8VPT2KCF/Nh7eirp5GVu2KlGq5cGv2InvAo7Ds=";
    };
  });
}
#+end_src
** signal-desktop
#+begin_src nix :exports both :tangle "~/.config/nixpkgs/nixos-flk/overlays/signal-desktop.nix"
let version = "1.34.5";
in
final: prev: {
  signal-desktop = prev.signal-desktop.overrideAttrs (o: {
    inherit version;
    src = prev.fetchurl {
      url = "https://updates.signal.org/desktop/apt/pool/main/s/signal-desktop/signal-desktop_${version}_amd64.deb";
      sha256 = "sha256-4VHErF8VdLtnGtKXHn9gdh2KnO4uAkNycnpHN7OeFuk=";
    };
  });
}
#+end_src
** ccls
#+begin_src nix :exports both :tangle "~/.config/nixpkgs/nixos-flk/overlays/ccls.nix"
final: prev: {
  ccls = prev.ccls.overrideAttrs (o: {
    src = prev.fetchFromGitHub{
      owner = "MaskRay";
      repo = "ccls";
      rev = "2ad71f1058cb8079d7a78d35b2dc1af4e282881d";
      sha256 = "sha256-+FiJRQNwCUP+HeT89NDdfKBzXZO805DJQS2bFJRg5Gc=";
    };
  });
}
#+end_src

* modules

** module list
#+begin_src nix :exports both :tangle "~/.config/nixpkgs/nixos-flk/modules/list.nix"
[
  ./ids/zeek
]
#+end_src

** zeek
#+begin_src nix :exports both :tangle "~/.config/nixpkgs/nixos-flk/modules/ids/zeek/default.nix"
{ config, lib, pkgs, ... }:
with lib;
let
  cfg = config.services.zeek;
  zeek-oneshot = pkgs.writeScript "zeek-oneshot" ''
   if [ ! -d "/var/lib/zeek/logs/current/stats.log" ];then
   ${cfg.package}/bin/zeekctl install || true
   rm -rf ${cfg.dataDir}/logs/current
   mkdir -p ${cfg.dataDir}/logs/current
   cd ${cfg.dataDir}/logs/current
   chown root:root /var/lib/zeek/logs/current
  ${cfg.dataDir}/scripts/run-zeek -1 -i ${cfg.interface} -U .status -p zeekctl -p zeekctl-live -p standalone -p local -p zeek local.zeek zeekctl zeekctl/standalone zeekctl/auto
    else
     cd ${cfg.dataDir}/logs/current
    ${cfg.dataDir}/scripts/run-zeek -1 -i ${cfg.interface} -U .status -p zeekctl -p zeekctl-live -p standalone -p local -p zeek local.zeek zeekctl zeekctl/standalone zeekctl/auto
  fi
  '';
  StandaloneConfig = ''
  [zeek]
  type=standalone
  host=${cfg.listenAddress}
  interface=${cfg.interface}
  '';

  ClusterConfig =  ''
  [logger]
  type=logger
  host=localhost
  [manager]
  type=manager
  host=localhost

  [proxy-1]
  type=proxy
  host=localhost

  [worker-1]
  type=worker
  host=localhost
  interface=eth0

  [worker-2]
  type=worker
  host=localhost
  interface=eth0
  '';

  NodeConf = pkgs.writeText "node.cfg" (if cfg.standalone then  StandaloneConfig else cfg.extraConfig);
  NetworkConf = pkgs.writeText "networks.cfg" cfg.network;

  PreShell = pkgs.writeScript "Pre-runZeek" ''
    if [ ! -d "/var/lib/zeek/logs" ];then
      mkdir -p  /var/lib/zeek/logs
     chown root:root /var/lib/zeek/logs
      fi
    if [ ! -d "/var/lib/zeek/spool" ];then
      mkdir -p  /var/lib/zeek/spool
     chown root:root /var/lib/zeek/spool
      fi
    if [ ! -d "/var/lib/zeek/etc" ];then
      mkdir -p  /var/lib/zeek/etc
     chown root:root /var/lib/zeek/etc
      fi
    if [ ! -d "/var/lib/zeek/scripts" ];then
      mkdir -p  /var/lib/zeek/scripts
     chown root:root /var/lib/zeek/scripts
      fi
    if [ ! -d "/var/lib/zeek/policy" ];then
      mkdir -p  /var/lib/zeek/policy
     chown root:root /var/lib/zeek/policy
      fi

   ln -sf ${NodeConf} /var/lib/zeek/etc/node.cfg
   ln -sf ${NetworkConf} /var/lib/zeek/etc/networks.cfg
   if [ ! -d "/var/lib/zeek/scripts/helpers" ];then
   cp -r ${cfg.package}/share/zeekctl/scripts/helpers /var/lib/zeek/scripts/
   cp -r ${cfg.package}/share/zeekctl/scripts/postprocessors /var/lib/zeek/scripts/
   fi
   cp -r ${cfg.package}/share/zeek/site/local.zeek /var/lib/zeek/policy
   for i in  run-zeek crash-diag         expire-logs        post-terminate     run-zeek-on-trace  stats-to-csv        check-config       expire-crash       make-archive-name  run-zeek           set-zeek-path             archive-log        delete-log     send-mail
   do
   ln -sf ${cfg.package}/share/zeekctl/scripts/$i /var/lib/zeek/scripts/
   done

        ${optionalString (cfg.privateScript != null)
          "echo \"${cfg.privateScript}\" >> ${cfg.dataDir}/policy/local.zeek"
         }
'';
in {

  options.services.zeek = {
    enable = mkOption {
      description = "Whether to enable zeek.";
      default = false;
      type = types.bool;
    };

    dataDir = mkOption {
      type = types.path;
      default = "/var/lib/zeek";
      description = ''
        Data directory for zeek. Do not change
      '';
    };

    package = mkOption {
      description = "Zeek package to use.";
      default = pkgs.zeek;
      defaultText = "pkgs.zeek";
      type = types.package;
    };

    standalone = mkOption {
      description = "Whether to enable zeek Standalone mode";
      default = true;
      type = types.bool;
    };

    interface = mkOption {
      description = "Zeek listen address.";
      default = "eth0";
      type = types.str;
    };

    listenAddress = mkOption {
      description = "Zeek listen address.";
      default = "localhost";
      type = types.str;
    };

    network = mkOption {
      description = "Zeek network configuration.";
      default = ''
      # List of local networks in CIDR notation, optionally followed by a
      # descriptive tag.
      # For example, "10.0.0.0/8" or "fe80::/64" are valid prefixes.

      10.0.0.0/8          Private IP space
      172.16.0.0/12       Private IP space
      192.168.0.0/16      Private IP space
      '';
      type = types.str;
    };

    privateScript = mkOption {
      description = "Zeek load private script path";
      default ="";
      type = types.str;
    };

    extraConfig = mkOption {
      type = types.lines;
      default = ClusterConfig;
      description = "Zeek cluster configuration.";
    };
  };

  config = mkIf cfg.enable {
    environment.systemPackages = [ cfg.package ];

    systemd.services.zeek = {
      description = "Zeek Daemon";
      after = [ "network.target" ];
      wantedBy = [ "multi-user.target" ];
      path = [ cfg.package pkgs.gawk pkgs.gzip ];
      preStart = ''
        ${pkgs.bash}/bin/bash ${PreShell}
        '';
      serviceConfig = {
        ExecStart = mkIf cfg.standalone ''
         ${pkgs.bash}/bin/bash ${zeek-oneshot}
          '';
        ExecStop  = "${pkgs.coreutils}/bin/kill -INT $MAINPID";
        User = "root";
        PrivateTmp="yes";
        PrivateDevices="yes";
        RuntimeDirectory = "zeek";
        RuntimeDirectoryMode = "0755";
        LimitNOFILE = "30000";
      };
    };
  };
}
#+end_src

** promnesia
#+begin_src nix :exports both :tangle "~/.config/nixpkgs/nixos-flk/modules/promnesia/default.nix"
{ config, lib, pkgs, ... }:

with lib;

let
  cfg = config.services.promnesia;
  configFile = pkgs.writeScript "config.py" cfg.config;
  PreShell = pkgs.writeScript "preRun-promnesia" ''
  if [ ! -d "$HOME/.local/share/promnesia.sqlite" ];then
     ${cfg.package}/bin/promnesia index --config ${configFile}
     fi
    '';
in
{
  options.services.promnesia = {
    enable = mkOption {
      description = "Whether to enable promnesia.";
      default = false;
      type = types.bool;
    };

    watcherPath = mkOption {
      type = types.path;
      default = "";
      description = ''
       if this path modified that will restart promnesia service automaticlly.
      '';
    };

    dbPath = mkOption {
      type = types.path;
      default = "";
      description = ''
        sqlite directory for promnesia
      '';
    };
    config  = mkOption {
      description = "write resource to config.py";
      default = ''
      '';
      type = types.str;
    };

    package = mkOption {
      description = "promnesia package to use.";
      default = pkgs.promnesia;
      type = types.package;
    };
  };
  config = mkIf cfg.enable {
    environment.systemPackages = [ cfg.package ];
    systemd.user.services.promnesia = {
      description = "promnesia Daemon";
      preStart = ''
      ${pkgs.bash}/bin/bash ${PreShell}
        '';
      serviceConfig = {
        ExecStart = mkIf cfg.enable ''
        ${cfg.package}/bin/promnesia serve
        '';
        Restart = "always";
      };
    } // optionalAttrs cfg.enable { wantedBy = [ "default.target" ]; };

    systemd.user.paths.promnesia-watcher = {
      wantedBy = [ "promnesia.service" ];
      pathConfig = {
        PathModified = cfg.watcherPath;
        Unit = "promnesia-restarter.service";
      };
    };
    systemd.user.services.promnesia-restarter = {
      serviceConfig.Type = "oneshot";
      wantedBy = [ "promnesia.service" ];
      script = ''
      systemctl --user restart promnesia.service
         '';
    };
  };
}
#+end_src

** xkeysnail
- [[https://github.com/mooz/xkeysnail/][mooz/xkeysnail: Yet another keyboard remapping tool for X environment]]

- [[https://github.com/Claude-Ray/dotfiles/blob/master/.config/systemd/user/xkeysnail.service][dotfiles/xkeysnail.service at master · Claude-Ray/dotfiles]]

  - [[https://emacs-china.org/t/xkeysnail/12155/13][虽然有人推过了, 再来推荐一波 xkeysnail, 功能更完善了一点 - 闲聊灌水 - Emacs China]]
* Flake
#+begin_src nix :exports both :tangle "~/.config/nixpkgs/nixos-flk/flake.nix"
{
  description = "User:GTrunSec - A highly structured configuration database.";

  inputs =
    {
      master.url = "nixpkgs/8bdebd463bc77c9b83d66e690cba822a51c34b9b";
      unstable.url = "nixpkgs/684d5d27136f154775c95005dcce2d32943c7c9e";
      nixos.url = "nixpkgs/8bdebd463bc77c9b83d66e690cba822a51c34b9b";
      home.url = "github:rycee/home-manager/bqv-flakes";
      nixpkgs-hardenedlinux = { url = "github:hardenedlinux/nixpkgs-hardenedlinux"; flake = false;};
      #photoprism-flake.url = "github:GTrunSec/photoprism-flake";
      photoprism-flake.url = "/home/gtrun/src/photoprism-flake";
      nuclear-flake.url = "github:GTrunSec/nuclear-music-flake";
      zeek-nix = { url = "github:hardenedlinux/zeek-nix/main"; flake = false;};
    };

  outputs = inputs@{ self, home, nixos, master, unstable, nixpkgs-hardenedlinux, photoprism-flake, nuclear-flake, zeek-nix}:
    let
      inherit (builtins) attrNames attrValues readDir;
      inherit (nixos) lib;
      inherit (lib) removeSuffix recursiveUpdate genAttrs filterAttrs;
      inherit (utils) pathsToImportedAttrs;

      utils = import ./lib/utils.nix { inherit lib; };

      system = "x86_64-linux";

      pkgImport = pkgs:
        import pkgs {
          inherit system;
          overlays = attrValues self.overlays
                     ++ [ (import ./pkgs/my-node-packages)
                          (import "${nixpkgs-hardenedlinux}/nix/python-packages-overlay.nix")
                          nuclear-flake.overlay
                        ];
          config = { allowUnfree = true; };
        };

      pkgset = {
        osPkgs = pkgImport nixos;
        pkgs = pkgImport master;
        unstable = pkgImport unstable;
      };

    in
    with pkgset;
    {
      nixosConfigurations =
        import ./hosts (recursiveUpdate inputs {
          inherit lib pkgset system utils;
        }
        );

      devShell."${system}" = import ./shell.nix {
        inherit pkgs;
      };

      overlay = (import ./pkgs);

      overlays =
        let
          overlayDir = ./overlays;
          fullPath = name: overlayDir + "/${name}";
          overlayPaths = map fullPath (attrNames (readDir overlayDir));
        in
        pathsToImportedAttrs overlayPaths;

      packages."${system}" =
        let
          packages = self.overlay osPkgs osPkgs ;
          overlays = lib.filterAttrs (n: v: n != "pkgs") self.overlays;

          overlayPkgs =
            genAttrs
              (attrNames overlays)
              (name: (overlays."${name}" osPkgs osPkgs)."${name}");
        in
        recursiveUpdate packages overlayPkgs;

      nixosModules =
        let
          # binary cache
          cachix = import ./cachix.nix;
          cachixAttrs = { inherit cachix; };

          # modules
          moduleList = import ./modules/list.nix;
          modulesAttrs = pathsToImportedAttrs moduleList;

          # profiles
          profilesList = import ./profiles/list.nix;
          profilesAttrs = { profiles = pathsToImportedAttrs profilesList; };

        in
        recursiveUpdate
          (recursiveUpdate cachixAttrs modulesAttrs)
          profilesAttrs;

      templates.flk.path = ./.;
      templates.flk.description = "https://github.com/GTrunSec/nixos-flk";
      defaultTemplate = self.templates.flk;
    };
}
#+end_src

* Cachix
- default.nix
  #+begin_src nix :exports both :tangle "~/.config/nixpkgs/nixos-flk/cachix/default.nix"
{ config, lib, pkgs, ... }:

{
  imports = [ ./ghcide-nix.nix
              ./ros.nix
            ];
}
  #+end_src

- ghcide-nix.nix
  #+begin_src nix :exports both :tangle "~/.config/nixpkgs/nixos-flk/cachix/ghcide-nix.nix"
{
  nix = {
    binaryCaches = [
      "https://ghcide-nix.cachix.org"
    ];
    binaryCachePublicKeys = [
      "ghcide-nix.cachix.org-1:ibAY5FD+XWLzbLr8fxK6n8fL9zZe7jS+gYeyxyWYK5c="
    ];
  };
}
  #+end_src

- ros.nix
  #+begin_src nix :exports both :tangle "~/.config/nixpkgs/nixos-flk/cachix/ros.nix"

{
  nix = {
    binaryCaches = [
      "https://ros.cachix.org"
    ];
    binaryCachePublicKeys = [
      "ros.cachix.org-1:dSyZxI8geDCJrwgvCOHDoAfOm5sV1wCPjBkKL+38Rvo="
    ];
  };
}

  #+end_src
